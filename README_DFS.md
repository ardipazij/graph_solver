# README: Реализация и отладка DFS (поиск в глубину)

## Описание задачи

В проекте реализуется визуализация алгоритма поиска в глубину (DFS) для неориентированного графа. Требовалось, чтобы алгоритм корректно посещал все достижимые вершины, а также чтобы визуализация отражала каждый шаг обхода.

## Проблема

**Изначальная проблема:**
- При запуске DFS с некоторых вершин (например, с вершины 3) не все вершины графа посещались (например, вершина 4 оставалась не посещённой), несмотря на то, что между ними было ребро.
- При запуске с других вершин (например, с вершины 4) все вершины посещались.
- При этом BFS работал корректно.

## Этапы решения

### 1. Общая (простая) реализация DFS
- Сначала был реализован классический DFS с использованием стека и глобального множества посещённых вершин (`self.visited`).
- Алгоритм работал так: из текущей вершины выбирался первый непосещённый сосед, к нему происходил переход (push в стек), и цикл по соседям прерывался (`return`).
- После возврата из глубины остальные соседи не обрабатывались, так как цикл был прерван.
- В результате, если у вершины было несколько соседей, DFS уходил только по одной ветке, а остальные оставались необработанными. Это приводило к тому, что часть вершин (например, вершина 4) не посещалась, если к ней не было прямого пути по первой ветке.
- Пример кода:
  ```python
  for neighbor in neighbors:
      if neighbor not in self.visited:
          # переход к соседу
          ...
          return  # цикл прерывается!
  ```

### 2. Пошаговая визуализация
- Для удобства отладки и обучения была добавлена пошаговая визуализация:
    - На каждом шаге подсвечивалась текущая вершина, ребро, путь.
    - В правой панели отображались переменные стека, посещённые вершины, родительские связи.
    - В пояснениях выводились сообщения о каждом действии (переход, возврат, обработка вершины).
- Однако логика обхода осталась прежней: после первого перехода к соседу цикл по соседям прерывался, и остальные соседи не обрабатывались.
- Это позволяло наглядно увидеть, что часть вершин остаётся не посещённой, и помогло быстро локализовать ошибку.

### 3. Исправление: обход всех соседей после возврата из глубины
- Был реализован классический подход, аналогичный тому, как это сделано в [programforyou.ru/graph-redactor](https://programforyou.ru/graph-redactor):
    - Для каждой вершины сохраняется индекс последнего просмотренного соседа (`self._dfs_neighbor_idx`).
    - После возврата из глубины цикл по соседям продолжается с того места, где был остановлен, а не прерывается.
    - Теперь, если у вершины несколько соседей, DFS после возврата из глубины продолжает обработку остальных, а не только первого.
    - Это гарантирует, что все достижимые вершины будут посещены, независимо от порядка обхода.
- Пример исправленного кода:
  ```python
  idx = self._dfs_neighbor_idx.get(vertex, 0)
  while idx < len(neighbors):
      neighbor = neighbors[idx]
      self._dfs_neighbor_idx[vertex] = idx + 1
      if neighbor not in self.visited:
          # переход к соседу
          ...
          return  # после возврата цикл продолжится с idx+1
      idx += 1
  # если все соседи обработаны — возврат назад
  ```
- Визуализация теперь отражает все шаги, возвраты и переходы, и ни одна вершина не остаётся не посещённой, если она достижима из стартовой.

## Итоговое решение

- Теперь DFS корректно посещает все вершины, достижимые из стартовой, даже если у вершины несколько соседей.
- Визуализация отражает каждый шаг обхода, включая возвраты и переходы по рёбрам.
- Алгоритм полностью соответствует классической модели DFS и поведению в популярных онлайн-редакторах графов.

---

**Если потребуется реализовать обход по всем компонентам связности (автоматически запускать DFS для всех не посещённых вершин) — это можно добавить отдельным циклом.** 