# Пошаговая визуализация алгоритма Дейкстры в проекте

## Как реализован алгоритм Дейкстры

- Алгоритм реализован в классе `DijkstraAlgorithm` (файл `algorithms/graph_algorithms.py`).
- Запуск происходит через интерфейс: пользователь выбирает "Поиск кратчайшего пути" в меню "Алгоритмы".
- После запуска:
  1. Пользователь выбирает **начальную вершину** (клик по вершине на графе).
  2. После этого выбирает **конечную вершину** (ещё один клик).
  3. После выбора обеих вершин запускается анимация пошагового выполнения алгоритма.
- Каждый шаг алгоритма выполняется по таймеру (QTimer), с возможностью паузы и изменения скорости.
- На каждом шаге:
  - Обновляется состояние переменных (расстояния, предыдущие вершины, посещённые и т.д.).
  - Подсвечиваются текущие вершины, рёбра, путь, начальная и конечная вершины.
  - Визуально выделяется найденный кратчайший путь (зелёным), начальная вершина (жёлтым), конечная (красным).

## Как реализован псевдокод

- Псевдокод для каждого алгоритма хранится в виде строки в методе `show_pseudocode` класса `MainWindow`.
- При запуске алгоритма соответствующий псевдокод отображается в правой панели (QTextEdit).
- На каждом шаге алгоритма вызывается метод `highlight_pseudocode_line`, который подсвечивает строку псевдокода, соответствующую текущему действию.
- Подсветка реализована через HTML-форматирование (выделение фона и текста нужной строки).
- Таким образом, пользователь видит, какой именно шаг алгоритма сейчас выполняется.

## Как реализованы пояснения

- Пояснения отображаются в отдельной панели справа (QTextEdit), которая может быть скрыта/показана кнопкой "Пояснения".
- На каждом шаге алгоритма в пояснения добавляется текстовое описание текущего действия (например, "Обрабатываем вершину 3", "Обновляем расстояние до вершины 5" и т.д.).
- Пояснения формируются в методах алгоритма (например, в `next_step` класса DijkstraAlgorithm) и передаются в виджет через метод `append`.
- Таким образом, пользователь получает подробный текстовый разбор каждого шага, что помогает понять логику работы алгоритма.

---

**В результате:**
- Пользователь видит не только сам граф и анимацию, но и подробный псевдокод с подсветкой и текстовые пояснения к каждому действию.
- Это делает обучение и анализ работы алгоритма максимально наглядным и удобным.

---

## Технические детали для разработчика

### Алгоритм Дейкстры

- **Класс:** `DijkstraAlgorithm` (файл `algorithms/graph_algorithms.py`).
- **Методы:**
  - `__init__(self, graph, start_vertex, end_vertex)`: инициализация алгоритма, принимает граф, начальную и конечную вершины.
  - `next_step(self)`: выполняет один шаг алгоритма, обновляет расстояния, предыдущие вершины и посещённые вершины.
  - `get_current_state(self)`: возвращает текущее состояние алгоритма (расстояния, предыдущие вершины, посещённые вершины).
- **Структура данных:**
  - `distances`: словарь, где ключ — вершина, значение — текущее расстояние от начальной вершины.
  - `previous`: словарь, где ключ — вершина, значение — предыдущая вершина в кратчайшем пути.
  - `visited`: множество посещённых вершин.
- **Пример вызова:**
  ```python
  dijkstra = DijkstraAlgorithm(graph, start_vertex, end_vertex)
  while not dijkstra.is_finished():
      dijkstra.next_step()
      current_state = dijkstra.get_current_state()
      # Обновление UI, подсветка вершин, рёбер и т.д.
  ```

### Псевдокод

- **Метод:** `show_pseudocode(self, algorithm_name)` в классе `MainWindow`.
- **Параметры:** `algorithm_name` — название алгоритма (например, "dijkstra").
- **Пример псевдокода для Дейкстры:**
  ```python
  pseudocode = """
  1. Инициализация: расстояние до начальной вершины = 0, до остальных = бесконечность.
  2. Пока есть непосещённые вершины:
     3. Выбрать вершину с минимальным расстоянием.
     4. Отметить её как посещённую.
     5. Для каждой соседней вершины:
        6. Если новое расстояние меньше текущего, обновить расстояние и предыдущую вершину.
  """
  ```
- **Подсветка строк:**
  - Метод `highlight_pseudocode_line(self, line_number)` подсвечивает строку псевдокода, соответствующую текущему шагу.
  - Пример вызова: `highlight_pseudocode_line(3)` подсветит строку "Выбрать вершину с минимальным расстоянием."

### Пояснения

- **Виджет:** `QTextEdit` в правой панели, управляемый кнопкой "Пояснения".
- **Метод:** `append(self, text)` для добавления текста в пояснения.
- **Пример пояснений на каждом шаге:**
  - "Обрабатываем вершину 3."
  - "Обновляем расстояние до вершины 5: 10 -> 8."
  - "Кратчайший путь найден: 1 -> 3 -> 5."
- **Формирование пояснений:**
  - В методе `next_step` класса `DijkstraAlgorithm` формируются пояснения на основе текущего состояния алгоритма.
  - Пример кода:
    ```python
    explanation = f"Обрабатываем вершину {current_vertex}."
    self.explanation_widget.append(explanation)
    ```

---

## Взаимосвязь между методами

- **Метод `next_step`**:
  - Выполняет один шаг алгоритма Дейкстры.
  - Обновляет словари `distances`, `previous` и множество `visited`.
  - После обновления вызывает `get_current_state` для получения текущего состояния.
  - Формирует пояснения на основе текущих значений переменных (например, `distances`, `previous`, `visited`).
  - Пример:
    ```python
    def next_step(self):
        # Логика шага алгоритма
        current_vertex = self._get_min_distance_vertex()
        self.visited.add(current_vertex)
        for neighbor in self.graph[current_vertex]:
            new_distance = self.distances[current_vertex] + self.graph[current_vertex][neighbor]
            if new_distance < self.distances[neighbor]:
                self.distances[neighbor] = new_distance
                self.previous[neighbor] = current_vertex
        # Формирование пояснений
        explanation = f"Обрабатываем вершину {current_vertex}. Текущие расстояния: {self.distances}."
        self.explanation_widget.append(explanation)
    ```

- **Метод `get_current_state`**:
  - Возвращает текущее состояние алгоритма (словари `distances`, `previous`, множество `visited`).
  - Используется для обновления UI и подсветки вершин, рёбер и т.д.
  - Пример:
    ```python
    def get_current_state(self):
        return {
            "distances": self.distances,
            "previous": self.previous,
            "visited": self.visited
        }
    ```

## Особенности технической реализации алгоритма Дейкстры

- **Использование словарей вместо массивов**:
  - В классической реализации Дейкстры часто используются массивы для хранения расстояний и предыдущих вершин.
  - В нашем проекте используются словари (`distances`, `previous`), что упрощает работу с вершинами, имеющими произвольные идентификаторы.
  - Пример:
    ```python
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start_vertex] = 0
    ```

- **Оптимизация выбора вершины с минимальным расстоянием**:
  - В классической реализации для выбора вершины с минимальным расстоянием используется линейный поиск по массиву.
  - В нашем проекте используется метод `_get_min_distance_vertex`, который выбирает вершину с минимальным расстоянием из непосещённых вершин.
  - Пример:
    ```python
    def _get_min_distance_vertex(self):
        unvisited = {v for v in self.graph if v not in self.visited}
        return min(unvisited, key=lambda v: self.distances[v])
    ```

## Как генерируются пояснения

- **Зависимость от текущих переменных**:
  - Пояснения формируются на основе текущих значений словарей `distances`, `previous` и множества `visited`.
  - Например, если текущая вершина — 3, а расстояние до вершины 5 обновлено с 10 до 8, пояснение будет: "Обрабатываем вершину 3. Обновляем расстояние до вершины 5: 10 -> 8."
  - Пример кода:
    ```python
    explanation = f"Обрабатываем вершину {current_vertex}. Текущие расстояния: {self.distances}."
    if neighbor in self.distances and self.distances[neighbor] != float('infinity'):
        explanation += f" Обновляем расстояние до вершины {neighbor}: {old_distance} -> {self.distances[neighbor]}."
    ```

- **Примеры пояснений для разных шагов**:
  - **Шаг 1:** "Инициализация: расстояние до начальной вершины = 0, до остальных = бесконечность."
  - **Шаг 2:** "Обрабатываем вершину 1. Текущие расстояния: {1: 0, 2: 5, 3: 10, 4: 15}."
  - **Шаг 3:** "Обрабатываем вершину 2. Обновляем расстояние до вершины 3: 10 -> 8."
  - **Шаг 4:** "Обрабатываем вершину 3. Обновляем расстояние до вершины 4: 15 -> 12."
  - **Шаг 5:** "Кратчайший путь найден: 1 -> 2 -> 3 -> 4."

---

## Подсветка рёбер и вершин в алгоритме Дейкстры

- **Определение текущей вершины**:
  - Текущая вершина определяется методом `_get_min_distance_vertex`, который выбирает вершину с минимальным расстоянием из непосещённых вершин.
  - Пример:
    ```python
    current_vertex = self._get_min_distance_vertex()
    ```

- **Подсветка рёбер**:
  - Рёбра, ведущие к соседним вершинам, которые обновляются, подсвечиваются.
  - Например, если текущая вершина — 3, а расстояние до вершины 5 обновлено, подсвечивается ребро (3, 5).
  - Пример кода:
    ```python
    for neighbor in self.graph[current_vertex]:
        if self.distances[neighbor] > self.distances[current_vertex] + self.graph[current_vertex][neighbor]:
            # Подсветка ребра (current_vertex, neighbor)
            self.highlight_edge(current_vertex, neighbor)
    ```

- **Подсветка вершин**:
  - **Текущая вершина**: подсвечивается жёлтым цветом.
  - **Посещённые вершины**: подсвечиваются серым цветом.
  - **Начальная вершина**: подсвечивается зелёным цветом.
  - **Конечная вершина**: подсвечивается красным цветом.
  - Пример кода:
    ```python
    def highlight_vertices(self):
        # Подсветка текущей вершины
        self.highlight_vertex(current_vertex, "yellow")
        # Подсветка посещённых вершин
        for vertex in self.visited:
            self.highlight_vertex(vertex, "gray")
        # Подсветка начальной и конечной вершин
        self.highlight_vertex(self.start_vertex, "green")
        self.highlight_vertex(self.end_vertex, "red")
    ```

---

**Итог:**
- Алгоритм Дейкстры реализован в классе `DijkstraAlgorithm` с методами `next_step` и `get_current_state`.
- Псевдокод отображается в `QTextEdit` и подсвечивается на каждом шаге через метод `highlight_pseudocode_line`.
- Пояснения формируются в методе `next_step` и выводятся в отдельный `QTextEdit` через метод `append`.
- Всё это делает визуализацию алгоритма максимально понятной и удобной для обучения и анализа. 